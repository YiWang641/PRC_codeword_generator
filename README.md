## PRC Watermarking Scheme

This repository implements a Pseudorandom Code (PRC) watermarking scheme in C++17. It allows you to generate watermarked codewords of fixed length and detect them with high reliability using parity-check sets.

---

### 1. Overview

Defaults (edit in `Config.h`):

* **Codeword length (`l`)**: 500 bits
* **Number of parity-check sets (`n`)**: 1,000,000
* **Checks per set (`k`)**: 136 pairs
* **Detection threshold (`t`)**: 101
* **Flip probability for Test 2 (`p`)**: 0.1

#### Workflow

1. **Encode**

   * Randomly choose one of the `n` sets and a watermark bit `id` (0/1).
   * Solve a small system of XOR constraints so that for each of the `k` pairs `(a, b)` in the chosen set, the generated codeword satisfies `cw[a] XOR cw[b] == id`.
   * Fill remaining bits randomly to produce a uniformly random solution.

2. **Detect**

   * For each of the `n` parity-check sets, compute the XOR of each pair in the received codeword.
   * Count zeros and ones; if either count ≥ `t`, the watermark is detected.

3. **Optimizations**

   * **Precomputed masks**: parity-pair masks are built once at startup to speed up encoding.
   * **Parallel detection**: uses OpenMP to distribute the detection loop across CPU cores.
   * **Table-based detection (`detect_precomputed`)**: precomputes all `l choose 2` XORs once, then performs threshold counts via fast lookups.

---

### 2. File Structure

```
├── Makefile             # build script with OpenMP support
├── README.md            # this file
├── Config.h             # adjust parameters here
├── PRCWatermarker.h     # class declaration
├── PRCWatermarker.cpp   # implementation (encode, detect, optimizations)
├── experiment.cpp       # demo using encode() & detect()
├── test1_timed.cpp      # Test 1: timed encode+detect on 1000 codewords
├── test2_evaluate.cpp   # Test 2: detection rates under noise vs. random
└── test1_codewords.txt  # generated by test1 at runtime
```

---

### 3. Configuring Parameters

Open **`Config.h`** and edit the default values for:

```cpp
    int    l = 500;       // codeword length
    size_t n = 1000000;   // number of parity-check sets
    int    k = 136;        // checks per set
    int    t = 101;        // detection threshold
    double p = 0.1;       // flip probability for Test 2
```

Then rebuild to apply your new parameters.

The parameters currently chosen satisfy >95% detection rate and <2% false positive rate.

---

### 4. Prerequisites

* **Compiler**: `g++` (≥7) or any C++17-capable compiler
* **OpenMP** support (for parallel detection)
* UNIX-like shell (Linux/macOS) or MinGW/MSYS on Windows

---

### 5. Building

```bash
make
```

Builds three executables:

* `experiment` – basic demo
* `test1`      – timed encode+detect test
* `test2`      – noise vs. random detection test

To build individually:

```bash
make experiment
make test1
make test2
```

Clean build artifacts:

```bash
make clean
```

---

### 6. Usage

All executables read parameters from `Config.h` at compile time.

#### `experiment`

```bash
./experiment
```

Performs one encode+detect cycle and prints the result.

#### `test1`

```bash
./test1
```

* Generates 1000 watermarked codewords, saves them to `test1_codewords.txt`.
* Times average encoding and detection durations.
* Verifies all detections succeed.

#### `test2`

```bash
./test2
```

* Generates 100 watermarked codewords, flips each bit with probability `p` (from `Config.h`), and counts detection successes.
* Generates 100 random codewords and counts false-positive detections.

---

### 7. Performance Notes

* Core memory footprint \~5 GiB for default parameters.
* OpenMP parallelizes detection across all available cores.

